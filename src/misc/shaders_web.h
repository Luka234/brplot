
#pragma once
//This file is autogenerated
#define SHADER_GRID_FS "#version 100\n" \
"precision mediump float;\n" \
"\n" \
"//x, y, width, height\n" \
"uniform vec4 resolution;\n" \
"uniform float time;\n" \
"uniform vec2 mouse;\n" \
"uniform vec2 zoom;\n" \
"uniform vec2 offset;\n" \
"uniform vec2 screen;\n" \
"\n" \
"varying vec4 color;\n" \
"\n" \
"float log10(float f) {\n" \
"    return log(f) / log(10.0);\n" \
"}\n" \
"\n" \
"float map(vec2 cPos, vec2 zoom_level, vec2 offset) {\n" \
"    vec2 fact = vec2(log10(zoom_level.x * 4.5), log10(zoom_level.y * 4.5));\n" \
"    vec2 fr = vec2(fract(fact.x), fract(fact.y));\n" \
"    vec2 baseMinor = floor(fact) - 1.0;\n" \
"    vec2 baseMajor = baseMinor + 1.;\n" \
"    vec2 divs = vec2(pow(10., baseMinor.x), pow(10., baseMinor.y));\n" \
"    vec2 divsMajor = vec2(pow(10., baseMajor.x), pow(10., baseMajor.y));\n" \
"    cPos *= zoom_level;\n" \
"    cPos += offset;\n" \
"    vec2 mcPosd = mod(cPos + divs/2., divs) - divs/2.;\n" \
"    vec2 mcPosdM = mod(cPos + divsMajor/2., divsMajor) - divsMajor/2.;\n" \
"\n" \
"    vec2 to = divs/(80. * (1. + 5.*(1. - 1.*fr)));\n" \
"    float yd = 1. - smoothstep(abs(mcPosd.y), 0.0, to.y);\n" \
"    float xd = 1. - smoothstep(abs(mcPosd.x), 0.0, to.x);\n" \
"    float ydM = 1. - smoothstep(abs(mcPosdM.y), 0.0, to.y*4.);\n" \
"    float xdM = 1. - smoothstep(abs(mcPosdM.x), 0.0, to.x*4.);\n" \
"    float k = 20.;\n" \
"    return max(max(yd, xd), max(ydM, xdM));\n" \
"}\n" \
"\n" \
"void main(void) {\n" \
"    vec2 fragCoord = gl_FragCoord.xy - (resolution.xy * vec2(1., -1.));\n" \
"    fragCoord.y -= screen.y - resolution.w;\n" \
"    vec2 cPos = ( fragCoord - .5*resolution.zw ) / resolution.w;\n" \
"    if (fragCoord.y < 2. || (fragCoord.y + 2.) > resolution.w || fragCoord.x - 2. < 0. || (fragCoord.x + 2.) > resolution.z) {\n" \
"      gl_FragColor = vec4(1.0);\n" \
"    } else {\n" \
"      gl_FragColor = vec4(0.2, 0.3, 0.5, 1.0)*vec4(map(cPos, zoom, offset));\n" \
"    }\n" \
"}\n" \

#define SHADER_LINE_FS "#version 100\n" \
"precision mediump float;\n" \
"\n" \
"varying vec2 normal;\n" \
"varying vec3 color;\n" \
"\n" \
"uniform vec2 screen;\n" \
"uniform vec4 resolution;\n" \
"uniform vec2 zoom;\n" \
"\n" \
"void main()\n" \
"{\n" \
"  float shade = 1. - smoothstep(length(normal), 0.0, .3) ;\n" \
"  if (shade == 0.) return;\n" \
"  vec4 cshade = vec4(shade);\n" \
"  vec4 r = resolution;\n" \
"  r.x += 2.;\n" \
"  r.z -= 4.;\n" \
"  r.y += 2.;\n" \
"  r.w -= 4.;\n" \
"  gl_FragColor.rgba = (vec4(color, 1.0) * clamp(cshade, 0., 1.));\n" \
"  vec2 fragCoord = gl_FragCoord.xy - (resolution.xy * vec2(1., -1.));\n" \
"  fragCoord.y -= screen.y - resolution.w;\n" \
"  gl_FragColor.a = gl_FragCoord.x <= r.x || gl_FragCoord.x >= (r.x + r.z) || fragCoord.y <= 2. || fragCoord.y + 2. >= resolution.w ? 0. : 1.;\n" \
"}\n" \

#define SHADER_LINE_VS "#version 100\n" \
"precision mediump float;\n" \
"\n" \
"attribute vec3 vertexPosition;\n" \
"// This is not normal. This is dx, dy, and length of the line.\n" \
"attribute vec3 vertexColor;\n" \
"attribute vec3 vertexNormal;\n" \
"\n" \
"varying vec2 normal;\n" \
"varying vec3 color;\n" \
"\n" \
"uniform vec2 offset;\n" \
"uniform vec4 resolution;\n" \
"uniform vec2 zoom;\n" \
"uniform vec2 screen;\n" \
"\n" \
"void main(void)\n" \
"{\n" \
"    color = vertexColor;\n" \
"    // TODO: make this uniform.\n" \
"    float thick = 0.09;\n" \
"    vec2 tg = vertexNormal.xy;\n" \
"    vec2 position = vertexPosition.xy;\n" \
"\n" \
"    normal = -vertexPosition.z * normalize(tg.yx * zoom * vec2(-1., 1.));\n" \
"    vec2 dif = normal * thick/2.;\n" \
"    position -= dif * (min(zoom * 0.1, 20000.0));\n" \
"\n" \
"    vec2 size = resolution.zw;\n" \
"\n" \
"    //Don't know why, but this value works...\n" \
"    float magic_number = size.y / screen.y * 2.;\n" \
"\n" \
"    vec2 fact = screen.xy / screen.yy;\n" \
"    vec2 fact2 = resolution.ww / screen.xy;\n" \
"    vec2 uv = position * magic_number;\n" \
"    uv -= offset * fact2 * fact * 2.;\n" \
"    uv /= zoom * fact;\n" \
"    uv += vec2(-1., 1.);\n" \
"    uv += resolution.xy/screen.xy*vec2(2., -2.);\n" \
"    uv += resolution.zw/screen.xy*vec2(1., -1.);\n" \
"    gl_Position = vec4(uv, 0., 1.0);\n" \
"}\n" \
"\n" \

#define SHADER_QUAD_FS "#version 100\n" \
"precision mediump float;\n" \
"\n" \
"varying vec2 normal;\n" \
"varying vec3 color;\n" \
"varying float dist;\n" \
"\n" \
"uniform vec2 screen;\n" \
"uniform vec4 resolution;\n" \
"uniform vec2 zoom;\n" \
"\n" \
"void main()\n" \
"{\n" \
"  vec4 r = resolution;\n" \
"  r.x += 2.;\n" \
"  r.z -= 4.;\n" \
"  r.y += 2.;\n" \
"  r.w -= 4.;\n" \
"  gl_FragColor.rgba = vec4(color, 1.0);\n" \
"  gl_FragColor.a *= gl_FragCoord.x <= r.x || gl_FragCoord.x >= (r.x + r.z) || \n" \
"   gl_FragCoord.y <= r.y || gl_FragCoord.y >= (r.y + r.w) ? 0. : 1.;\n" \
"}\n" \

#define SHADER_QUAD_VS "#version 100\n" \
"precision mediump float;\n" \
"\n" \
"attribute vec3 vertexPosition;\n" \
"attribute vec3 vertexColor;\n" \
"// This is not normal. This is dx, dy, and length of the line.\n" \
"attribute vec3 vertexNormal;\n" \
"\n" \
"varying vec2 normal;\n" \
"varying vec3 color;\n" \
"varying float dist;\n" \
"\n" \
"uniform vec2 offset;\n" \
"uniform vec4 resolution;\n" \
"uniform vec2 zoom;\n" \
"uniform vec2 screen;\n" \
"\n" \
"void main(void)\n" \
"{\n" \
"    dist = vertexPosition.z;\n" \
"    normal = vertexNormal.xy;\n" \
"    color = vertexColor;\n" \
"    vec2 position = vertexPosition.xy;\n" \
"\n" \
"    vec2 size = resolution.zw;\n" \
"\n" \
"    //Don't know why, but this value works...\n" \
"    float magic_number = size.y / screen.y * 2.;\n" \
"\n" \
"    vec2 fact = screen.xy / screen.yy;\n" \
"    vec2 fact2 = resolution.ww / screen.xy;\n" \
"    vec2 uv = position * magic_number;\n" \
"    uv -= offset * fact2 * fact * 2.;\n" \
"    uv /= zoom * fact;\n" \
"    uv += vec2(-1., 1.);\n" \
"    uv += resolution.xy/screen.xy*vec2(2., -2.);\n" \
"    uv += resolution.zw/screen.xy*vec2(1., -1.);\n" \
"    gl_Position = vec4(uv, 0., 1.0);\n" \
"}\n" \
"\n" \

